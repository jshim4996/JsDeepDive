/**
 * 컴퓨터는 CPU 를 통해 계산을
 * 메모리 를 통해 값(데이터) 를 저장한다.
 * JS 엔진은 개발자가 직접 메모리 제어 하는것을 허용하지 않는다.
 * 변수는 하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 공간을 식별하기 위해 붙인 이름이다.
 *
 */

//변수는 하나의 값을 저장하기 위한 수단
var userId = 1;
//변수는 객체나 배열같은 자료구조를 사용하면 여러개의 값을 하나로 그룹화 해서 하나의 값처럼 사용할수 있다.
var users = ["준", "예지"];
var user = {
  name: "joon",
  age: 31,
};

// calcul 은 변수이름
// 30 는 변수의 값
// 변수에 값을 저장하는 것을 할당
var calcul = 30;
// 변수에 값을 읽어들이는 것을 참조
calcul;

/**
 * 식별자는 메모리 주소값을 기억하고 있다.
 * 식별자는 메모리상에 존재하는 어떤값을 식별 할수있는 이름을 모두 지칭한다
 * => 함수 이름, 클래스 이름 등등
 * 선언을 통해 JS 엔진에 식별자를 알린다.
 *
 * 변수 선언을 통해 데이터를 저장할 공간을 확보하고 변수와 메모리 주소값을 연결 한다.
 *
 * 변수 호이스팅 이란 코드가 실행 되는 런타입 이전에 소스코드에 대해 평가 과정을 거치게 된다.
 * 이평과 과정 에서 변수 선언이 실행된다. => 마치 변수 선언이 코드 맨위로 올려져서 실행 되는것처럼
 */

// 변수 호이스팅이 실행되어 코드상에서 아직 선언되지 않았을 score 가 호출된다.
console.log(score);

// var 키워드를 통해 변수 선언을 할경우 메모리 할당과 더불어 변수에 암묵적으로 undefined 를 초기값으로 할당한다. (선언만 했을경우)
var score;

/**
 * 변수 선언은 런타임 이전에 실행 되지만, 변수 할당은 런타임 환경에서 실행된다.
 * 하나의 문으로 변수 선언과 할당을 동시에 실행 하더라도 JS 는 선언과 할당을 분리하여
 * 선언은 런타임 이전에, 할당은 런타임에 실행한다.
 */

console.log(score2); // undefind 출력

var score2 = 80;

console.log(score2); // 80 출력

console.log(score3); // undefind 출력

score3 = 100; // 변수가 런타임 이전에 선언 되어있기에 코드상 변수 선언 전이지만 할당이 된다.
var score3;

console.log(score3); // 80 출력

/**
 * 변수 재할당의 경우 이미 메모리상에 저장되어있는 값을 새로 전달 받은 값으로 바꾸는것이 아니라,
 * 새로운 메모리 주소에 값을 저장하고 식별자 에 새롭게 저장된 메모리 주소를 기억시킨다.
 * 변수 선언과 변수값 할당을 하나의 문으로 작성한것 또한 선언시 묵시적 초기값 할당, 갑 재할당이 이루어지는 것이다.
 * 사용하지 안는 메모리의 값을 가비지 컬렉터가 메모리값을 자동 헤제한다. => 사용자는 해제 시점을 알수 없다.
 */

var score4 = 100;
score4 = 200; // 기존 100의 메모리 값을 바꾸는 것이 아닌 새로운 메모리 주소에 값을 저장한다.
